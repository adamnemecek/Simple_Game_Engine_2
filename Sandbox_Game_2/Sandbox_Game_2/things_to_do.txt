- general cleanup
    - change all #includes to use 
        - / instead of \ (painstaking, but should do for the sake of future cross-platform-ness)
        - <> for std includes and for 3rd party includes like middleware and FreeType stuff
        - "" for my headers
    - CTRL-KF for proper spacing
- (done) add a "scene" class that stores as orders entities
- (done) add support for scene loading from a file
- (done) add support for multiple simultaneous shader programs
- (in progress) add support for geometry loading from Blender3D
- (done) change entities to use dual-quaternions for position and orientation instead of the current mix of vec3 (position) and fquat (orientation)
- (?) an AABB class tht stores vertex locations
- Entity constructor should NOT use a memset(...) to clear out the data
- relegate shape loading from a Blender3D OBJ file to its own class like ShapeGenerator
- re-name ShapeGenerator to PrimitiveGenerator
- create an "air particle" structure
    - position
    - position on previous frame
    - radius of collision
    - sum of total forces acting upon the particle on this frame
    - current velocity vector
    - mass
    - (for eventual more fancy stuff) particle type (O2, CO2, etc.)
    - value of repulsive force that is linear regressed from 0 at the edge of the collision sphere to full value at the center
- Particles
    - create a particle manager base class that does particle initialization
    - create a particle manager for circles
    - create another for emission on a plane
- create a particle manager 
    - TODO: store IDs instead of pointers in the "active particles" and "relaunch these" collections.  On a 64bit system, a pointer is 8 bytes, while a 16bit integer (unsigned is good for up to ~65,000) is just 2 bytes.  If you go beyond this, then a 32bit unsigned integer is still only 4 bytes.  More compact memory => better cache locality => better performance.
    - requires:
        - max number of particles to handle
        - a region inside of which they exist and outside of which they are reclaimed
        - a region in which they are generated
        - a direction in which the particles are spewed
        - Ex: (Wind tunnel box) particles are emitted from a plane at one end of a box and travel towards the other end of the box 
        - Ex: (Wind tunnel cylinder) same as the box, but particles are emitted from a circular plane and travel down a cylinder
        - Ex: particles are emitted from a point in all directions
        - Ex: particles are emitted from the surface of a sphere
    - "update" method
        - ??take a "wind" vector argument that will influence the forces on the air particles??
    - stage 1: particle spawning and particle reclamation when it goes out of range
        - (1a) spawning from 
            - a point in all directions
            - a surface of a plane in a single direction
        - (1b) reclaimed after exiting
            - a sphere
            - a box
            - a cylinder
    - stage 2: collision detection between particles from one frame to the next
        - detect 
            - octal region splitting for efficiency
            - stepping (10 steps? 20?) along the position vectors of two particles from previous frame to current frame and seeing if they overlap at all
        - add up repulsive forces on a single particle when it runs into the collision region of any number of nearby particles
        - resolve forces acting on particle to alter existing velocity vector
    - stage 3: collision with geometry
- create a particle renderer
- GPU development: 
    - stage 1: handle particle position updates without collisions
    - stage 2: stage 1 + collisions, and change particle color to reflect the magnitude of the forces on that particle
    - stage 3: stage 2 + collisions with geometry
        handle particle updates 
- calculate a way to dump all vertices into a single, giant vertex array, and then control rendering just with indices and render types
- (done) FreeTypeAtlas: use a VAO to encapsulate the glVertexAttribPointer and buffer binding
- FreeTypeAtlas: Use texture sampler binding.  Right now, the texture parameters are set once for texture 0, but if there is ever a second texture, these will need to be set again at every draw call.  
- (done) Encapsulate the "shape data" pointers coming out of the "shape generator" in a smart pointer.
- re-design
    - Rendering: A single renderer that coordinates different renders, each with their own program IDs and their own collections of things to render and their own uniforms, etc.  The single renderer's job is 
        (1) to determine the viewport
        (2) determine the camera to render at
        (3) determine and distribute the perspective matrix to the individual renderers
        (4) call the individual renderers in the proper order
        (5) clears the color and depth bits
    - Use an ECS (yes, for particles too)
    - Multithreaded (one threat for rendering, another thread for others)
    - the "scene" class:
        - consider what it actually needs to hold (do I really need a vector of unique pointers for the particle manager?)
        - load from JSON file instead of XML
        - primitive shape loading should probably handle failure instead of crashing whole program
        - take more of a managerial role in loading
        - hand off particle manger updating to the GPU
        - hand off collision calculations to the GPU
    - texture loading to use samplers (already doing that in shader (I think), but not in C++ code)
        - https://www.opengl.org/wiki/Sampler_Object
        - https://www.reddit.com/r/opengl/comments/4j82g9/is_there_a_vaolike_thing_for_textures_that_stores/713
    - entity-component system to be more pure (alternately, adopt EntityX)
        - https://www.reddit.com/r/gamedev/comments/4l2qck/entitycomponent_by_encapsulated_class_or_by_dumb/
    

